# Flow Matching 参数详解与配置指南

## 📚 核心参数详解

### 1️⃣ `flow_matching_type` - Flow Matching 类型

#### `conditional` (推荐)
```yaml
flow_matching_type: 'conditional'
```

**原理**:
- 学习从噪声 x₀ 到数据 x₁ 的直接路径
- 使用简单的线性插值: x_t = (1-t)·x₀ + t·x₁
- 目标速度场: v_t = x₁ - x₀ (常数)

**优点**:
- ✅ 训练最简单、最稳定
- ✅ 实现成熟，bug少
- ✅ 适合 95% 的场景

**缺点**:
- ❌ 理论上不是最优路径

**推荐场景**: **首选！** 适合所有场景，尤其是首次使用

---

#### `optimal_transport`
```yaml
flow_matching_type: 'optimal_transport'
```

**原理**:
- 基于最优传输理论
- 寻找数据点之间的最优配对
- 理论上路径更短、更优

**优点**:
- ✅ 理论上更优
- ✅ 可能用更少步数

**缺点**:
- ❌ 需要计算配对（Sinkhorn算法）
- ❌ 实现复杂
- ❌ 当前版本是简化版本

**推荐场景**: 高级用户，对性能有极致要求

---

#### `rectified`
```yaml
flow_matching_type: 'rectified'
```

**原理**:
- 通过多次"修正"使轨迹更直
- 第1次训练 → 生成样本 → 用生成的样本重新训练
- 迭代多次后轨迹接近直线

**优点**:
- ✅ 最终可用极少步数（5步甚至1步）
- ✅ 理论上最优

**缺点**:
- ❌ 需要多次训练迭代
- ❌ 第一次训练效果不佳

**推荐场景**: 有时间多次训练，追求极致速度

---

### 2️⃣ `flow_sigma` - 噪声水平

```yaml
flow_sigma: 0.0  # 范围: [0.0, 0.1]
```

**数学原理**:
```python
# 确定性流（sigma = 0）
x_t = (1-t) * x₀ + t * x₁

# 随机流（sigma > 0）
x_t = (1-t) * x₀ + t * x₁ + σ * ε
     ↑ 确定性部分      ↑ 随机部分
```

#### 不同值的效果

| sigma | 含义 | 效果 | 推荐场景 |
|-------|------|------|----------|
| **0.0** | 纯 ODE | 完全确定性，可复现 | **质量优先** ✅ |
| 0.001-0.01 | 轻微随机 | 增加轻微多样性 | 需要多样性但保持质量 |
| 0.05-0.1 | 较强随机 | 类似 SDE，多样性强 | 生成多样化样本 |

**实验建议**:
1. **首次训练**: 使用 `0.0`
2. **如果动作过于僵硬**: 尝试 `0.001`
3. **如果需要探索性**: 尝试 `0.01`

**注意**: sigma > 0 会降低 Flow Matching 的核心优势（确定性）

---

### 3️⃣ `ode_solver` - ODE 求解器

#### `euler` (欧拉方法)
```yaml
ode_solver: 'euler'
```

**算法**:
```python
def euler_step(x, v, dt):
    return x + v * dt  # 一次前向传播
```

**特点**:
- ⚡ 速度: 最快
- 📊 精度: O(dt²)
- 💻 计算: 每步 1 次模型调用

**误差分析**:
- 10步: 总误差 ~0.1
- 20步: 总误差 ~0.025
- 50步: 总误差 ~0.004

**推荐**: 实时控制、快速迭代

---

#### `rk4` (龙格-库塔4阶)
```yaml
ode_solver: 'rk4'
```

**算法**:
```python
def rk4_step(x, model, t, dt):
    k1 = model(x, t)
    k2 = model(x + 0.5*dt*k1, t + 0.5*dt)
    k3 = model(x + 0.5*dt*k2, t + 0.5*dt)
    k4 = model(x + dt*k3, t + dt)
    return x + (k1 + 2*k2 + 2*k3 + k4) * dt / 6
```

**特点**:
- 🐢 速度: 慢 4 倍（每步4次模型调用）
- 📊 精度: O(dt⁵) → **远超 Euler**
- 💻 计算: 每步 4 次模型调用

**误差对比**:
| 步数 | Euler 误差 | RK4 误差 | RK4 优势 |
|------|-----------|---------|----------|
| 10   | 0.10      | 0.0001  | **1000x** 🚀 |
| 20   | 0.025     | 0.000003| **8000x** 🚀 |

**推荐**: **质量优先时使用** ✅

---

### 4️⃣ `num_inference_steps` - 推理步数

```yaml
num_inference_steps: 30  # 可选: 5-100
```

**原理**: ODE 积分的离散化步数

```
轨迹: x₀ → x₁
步数越多 → 积分越精确 → 质量越高
```

#### 步数选择指南

| 步数 | 质量 | 速度 | Euler | RK4 | 推荐场景 |
|------|------|------|-------|-----|----------|
| **5** | ⭐⭐ | ⚡⚡⚡ | 10ms | 40ms | 极速实时 |
| **10** | ⭐⭐⭐ | ⚡⚡⚡ | 20ms | 80ms | 实时控制 |
| **20** | ⭐⭐⭐⭐ | ⚡⚡ | 40ms | 160ms | 平衡 |
| **30** | ⭐⭐⭐⭐⭐ | ⚡ | 60ms | 240ms | 高质量 ✅ |
| **50** | ⭐⭐⭐⭐⭐ | 🐢 | 100ms | 400ms | 离线评估 |

**与 Diffusion 对比**:
- Diffusion: 通常需要 50-100 步
- Flow Matching: 10-30 步即可达到相同质量

**推荐策略**:
1. **首次训练**: 30 步（高质量验证）
2. **质量确认后**: 逐步降低到 20、15 步
3. **找到最佳平衡点**: 质量刚好满足 + 速度最快

---

## 🎯 配置方案推荐

### 方案 1: 极致质量（首次推荐）⭐⭐⭐⭐⭐

```yaml
use_flow_matching: True
flow_matching_type: 'conditional'
flow_sigma: 0.0
ode_solver: 'rk4'
num_inference_steps: 30
```

**特点**:
- 质量: ⭐⭐⭐⭐⭐ (最高)
- 速度: ⭐⭐⭐ (仍比 Diffusion 快 2-3倍)
- 稳定性: ⭐⭐⭐⭐⭐

**适用**: 
- ✅ 第一版本训练
- ✅ 离线评估
- ✅ 演示视频
- ✅ 质量验证

**推理时间**: ~240ms/action (估算)

---

### 方案 2: 质量-速度平衡 ⭐⭐⭐⭐

```yaml
use_flow_matching: True
flow_matching_type: 'conditional'
flow_sigma: 0.0
ode_solver: 'euler'
num_inference_steps: 20
```

**特点**:
- 质量: ⭐⭐⭐⭐ (优秀)
- 速度: ⭐⭐⭐⭐ (快)
- 稳定性: ⭐⭐⭐⭐⭐

**适用**:
- ✅ 大多数实际应用
- ✅ 在线测试
- ✅ 日常训练

**推理时间**: ~40ms/action

---

### 方案 3: 极速实时 ⚡⚡⚡

```yaml
use_flow_matching: True
flow_matching_type: 'conditional'
flow_sigma: 0.0
ode_solver: 'euler'
num_inference_steps: 10
```

**特点**:
- 质量: ⭐⭐⭐ (良好)
- 速度: ⭐⭐⭐⭐⭐ (极快)
- 稳定性: ⭐⭐⭐⭐

**适用**:
- ✅ 高频控制 (>20Hz)
- ✅ 实时机器人控制
- ✅ 资源受限设备

**推理时间**: ~20ms/action

---

## 🔬 实验建议流程

### 第一阶段: 质量验证（1-2周）

**目标**: 验证 Flow Matching 是否有效

**配置**: 方案1 - 极致质量
```yaml
ode_solver: 'rk4'
num_inference_steps: 30
```

**评估指标**:
1. 训练损失曲线
2. 任务成功率 vs Diffusion baseline
3. 动作平滑度
4. 轨迹质量

**判断标准**:
- ✅ 成功率 ≥ Diffusion baseline
- ✅ 训练稳定，损失下降
- → 进入第二阶段

---

### 第二阶段: 速度优化（1周）

**目标**: 在保持质量的前提下提速

**实验步骤**:
1. **降低推理步数**:
   ```yaml
   num_inference_steps: [30, 25, 20, 15, 10]
   ```
   找到质量刚好满足要求的最少步数

2. **测试求解器**:
   ```yaml
   ode_solver: 'euler'  # 与 RK4 对比
   ```
   评估 Euler 的质量损失是否可接受

3. **记录性能**:
   | 配置 | 成功率 | 推理时间 | 是否可用 |
   |------|--------|----------|----------|
   | RK4+30 | 85% | 240ms | ✅ |
   | RK4+20 | 84% | 160ms | ✅ |
   | Euler+20 | 83% | 40ms | ✅ |
   | Euler+10 | 78% | 20ms | ❓ |

---

### 第三阶段: 部署优化（按需）

**根据实际需求选择**:

| 应用场景 | 推荐配置 | 原因 |
|----------|---------|------|
| 离线轨迹生成 | RK4 + 50步 | 无时间限制 |
| 机器人控制 (10Hz) | Euler + 10步 | 需要 <100ms |
| 机器人控制 (50Hz) | Euler + 5步 | 需要 <20ms |
| 演示视频 | RK4 + 30步 | 追求视觉效果 |

---

## 📝 实用 Tips

### Tip 1: 先质量，后速度

❌ 错误做法:
```
立即使用最快配置 → 效果不好 → 怀疑 Flow Matching
```

✅ 正确做法:
```
高质量配置验证 → 确认有效 → 逐步优化速度
```

### Tip 2: 小步快跑

不要一次改太多参数，每次只改一个：
```
1. RK4 + 30步 (baseline)
2. RK4 + 20步 (降步数)
3. Euler + 20步 (换求解器)
4. Euler + 15步 (继续降)
```

### Tip 3: 记录实验结果

建立实验日志：
```
实验1: RK4 + 30步
- 训练时间: 8小时
- 成功率: 85%
- 推理时间: 240ms
- 结论: 质量很好，可以降低步数

实验2: RK4 + 20步
- 成功率: 84% (下降1%)
- 推理时间: 160ms (提升33%)
- 结论: 可接受，继续测试
```

---

## 🎬 快速开始

**立即使用高质量配置训练**:

```bash
# 使用优先质量配置
python train_policy.py policy=flow_matching_high_quality

# 或者修改 flow_matching_config.yaml:
# ode_solver: 'rk4'
# num_inference_steps: 30
python train_policy.py policy=flow_matching_config
```

**预期结果**:
- 训练稳定，损失平稳下降
- 生成质量优秀
- 推理时间 ~240ms（仍比 Diffusion 快 2-3倍）

---

**祝训练顺利！有问题随时问我！** 🚀

